/**
* Copyright Â© DiamondMVC 2018
* License: MIT (https://github.com/DiamondMVC/Diamond/blob/master/LICENSE)
* Author: Jacob Jensen (bausshf)
*/
module diamond.web.soap.parser;

import std.string : toLower, strip, format;
import std.file : write;
import std.array : split;
import std.algorithm : endsWith;

import diamond.xml;
import diamond.web.soap.soaptype;
import diamond.web.soap.complextype;
import diamond.web.soap.simpletype;
import diamond.web.soap.element;
import diamond.errors.exceptions.soapexception;

/**
* Parses a wsdl document into a d module.
* Params:
*   name =       The name of the service.
*   wsdl =       The path to the wsdl file.
*   document =   The wsdl document.
*   moduleName = The name of the resulting d module.
*/
package(diamond.web.soap) void parseWsdl(string name, string wsdl, XmlDocument document, string moduleName)
{
  auto types = document.root.getByTagName("types");

  if (!types || types.length != 1)
  {
    types = document.root.getByTagName("wsdl:types");
  }

  if (!types || types.length != 1)
  {
    return;
  }

  auto schemas = types[0].getByTagName("xs:schema");

  if (!schemas || !schemas.length)
  {
    return;
  }

  string wsdlResult = q{/**
* This file was generated by Diamond.
* Service: %s
* Module: %s
* Wsdl: %s
*/
module %s;
import diamond.web.soap.datatypes;
}.format(name, moduleName, wsdl, moduleName);

  foreach (schema; schemas)
  {
    auto result = parseSchema(schema);

    if (result && result.length)
    {
      wsdlResult ~= parseDTypes(result);
    }
  }

  // TODO: Parse the rest of the wsdl

  write("__services/" ~ name ~ ".d", wsdlResult);
}

private:
/**
* Parses a schema.
* Params:
*   schema = The schema to parse.
* Returns:
*   The parsed soap types from the schema.
*/
SoapType[] parseSchema(XmlNode schema)
{
  auto elementFormDefaultAttribute = schema.getAttribute("elementFormDefault");
  auto elementFormDefault = elementFormDefaultAttribute ? elementFormDefaultAttribute.value : "";

  auto targetNamespaceAttribute = schema.getAttribute("targetNamespace");
  auto targetNamespace = targetNamespaceAttribute ? targetNamespaceAttribute.value : "";

  if (!schema.children || !schema.children.length)
  {
    return null;
  }

  SoapType[] result;

  foreach (child; schema.children)
  {
    switch (child.name.toLower())
    {
      case "xs:complextype":
      {
        result ~= parseComplexType(child);
        break;
      }

      case "xs:simpletype":
      {
        result ~= parseSimpleType(child);
        break;
      }

      case "xs:attribute": break; // Although unsupported, attributes such as unions shouldn't break parsing.

      case "xs:element":
      {
        result ~= parseElementType(child);
        break;
      }

      default:
      {
        throw new SoapException("Unsupported type definition.");
      }
    }
  }

  return result;
}

/**
* Parses an element type.
* Params:
*   elementTypeNode = The element node.
* Returns:
*   A soap type equivalent to the parsed element type.
*/
SoapType parseElementType(XmlNode elementTypeNode)
{
  auto nameAttribute = elementTypeNode.getAttribute("name");
  auto name = nameAttribute ? nameAttribute.value.strip() : null;

  if (!name || !name.length)
  {
    throw new SoapException("Expected an element type name.");
  }

  if (!elementTypeNode.children || !elementTypeNode.children.length)
  {
    throw new SoapException("'%s' is an empty element type.".format(name));
  }

  auto type = elementTypeNode.children[0];

  if (type.name.toLower() != "xs:complextype" && type.name.toLower() != "xs:simpletype")
  {
    throw new SoapException("Expected a simple or complex type for '%s'.".format(name));
  }

  final switch (type.name.toLower())
  {
    case "xs:complextype":
    {
      type.addAttribute("name", name);
      auto complexType = parseComplexType(type);

      return complexType;
    }

    case "xs:simpletype":
    {
      type.addAttribute("name", name);
      auto simpleType = parseSimpleType(type);

      return simpleType;
    }
  }
}

/**
* Parses a simple type.
* Params:
*   simpleTypeNode = The simple type node.
* Returns:
*   The simple typed parsed.
*/
SoapSimpleType parseSimpleType(XmlNode simpleTypeNode)
{
  auto nameAttribute = simpleTypeNode.getAttribute("name");
  auto name = nameAttribute ? nameAttribute.value.strip() : null;

  if (!name || !name.length)
  {
    throw new SoapException("Expected a simple type name.");
  }

  if (!simpleTypeNode.children || simpleTypeNode.children.length != 1)
  {
    throw new SoapException("'%s' is either an empty simple type or has too many defintions.".format(name));
  }

  auto type = simpleTypeNode.children[0];

  switch (type.name.toLower())
  {
    case "xs:restriction":
    {
      auto baseAttribute = type.getAttribute("base");
      auto base = baseAttribute ? baseAttribute.value.strip() : null;

      if (!base || base.split(":").length != 2)
      {
        throw new SoapException("'%s' has no valid base type.");
      }

      base = base.split(":")[1];

      return new SoapSimpleType(name, base, SoapSimpleTypeDefinition.restriction);
    }

    case "xs:list":
    {
      auto itemTypeAttribute = type.getAttribute("itemType");
      auto itemType = itemTypeAttribute ? itemTypeAttribute.value.strip() : null;

      if (!itemType || itemType.split(":").length != 2)
      {
        throw new SoapException("'%s' has no valid item type.");
      }

      itemType = itemType.split(":")[1];

      return new SoapSimpleType(name, itemType, SoapSimpleTypeDefinition.list);
    }

    default:
    {
      throw new SoapException("Unsupported simple type definition.");
    }
  }
}

/**
* Parses a complex type.
* Params:
*   complexTypeNode = The complex node.
* Returns:
*   The complex node parsed.
*/
SoapComplexType parseComplexType(XmlNode complexTypeNode)
{
  auto nameAttribute = complexTypeNode.getAttribute("name");
  auto name = nameAttribute ? nameAttribute.value.strip() : null;

  if (!name || !name.length)
  {
    throw new SoapException("Expected a complex type name.");
  }

  if (!complexTypeNode.children || !complexTypeNode.children.length)
  {
    throw new SoapException("'%s' is an empty complex type.".format(name));
  }

  auto sequence = complexTypeNode.children[0];

  if (sequence.name.toLower() != "xs:sequence")
  {
    throw new SoapException("Expected a sequence element for '%s'.".format(name));
  }

  auto complexType = new SoapComplexType(name);

  auto elements = sequence.getByTagName("xs:element");

  if (elements && elements.length)
  {
    foreach (elementNode; elements)
    {
      auto element = parseElement(elementNode);

      complexType.addElement(element);
    }
  }

  return complexType;
}

/**
* Parses an element.
* Params:
*   elementNode = The element.
* Returns:
*   A soap element equivalent to the element node.
*/
SoapElement parseElement(XmlNode elementNode)
{
  auto nameAttribute = elementNode.getAttribute("name");
  auto name = nameAttribute ? nameAttribute.value.strip() : null;

  if (!name || !name.length)
  {
    throw new SoapException("Expected an element name.");
  }

  auto typeAttribute = elementNode.getAttribute("type");
  auto type = typeAttribute ? typeAttribute.value.strip() : null;

  if (!type || type.split(":").length != 2)
  {
    throw new SoapException("Element '%s' has no type.".format(name));
  }

  type = type.split(":")[1];

  if (elementNode.hasAttribute("minOccurs") || elementNode.hasAttribute("maxOccurs"))
  {
    type ~= "[]";
  }

  return new SoapElement(name, type);
}

/**
* Parses an array of soap types into d types.
* Params:
*   soapTypes = The array of soap types.
* Returns:
*   A string equivalent to all the d types.
*/
string parseDTypes(SoapType[] soapTypes)
{
  if (!soapTypes || !soapTypes.length)
  {
    return "";
  }

  string result;

  enum classTypeFormat = q{
final class %s : SoapEnvelopeType
{
  public:
  final:
  this() {}

%s}
  };

  enum classTypeElementFormat = "  %s %s;\r\n";

  enum aliasTypeFormat = "public alias %s = %s;\r\n";

  foreach (type; soapTypes)
  {
    auto complex = cast(SoapComplexType)type;

    if (complex)
    {
      string elementResult = "";

      if (complex.elements)
      {
        foreach (element; complex.elements)
        {
          if (complex.elements.length == 1 && element.type.endsWith("[]"))
          {
            elementResult ~= classTypeElementFormat.format(element.type, "_array_");
            elementResult ~= classTypeElementFormat.format("alias", "_array_ this");
          }
          else if (element.type == element.name)
          {
            elementResult ~= classTypeElementFormat.format(element.type, "_%s_".format(element.name));
          }
          else
          {
            elementResult ~= classTypeElementFormat.format(element.type, element.name);
          }
        }
      }

      result ~= classTypeFormat.format(complex.name, elementResult);
      continue;
    }

    auto simpleType = cast(SoapSimpleType)type;

    if (simpleType)
    {
      final switch (simpleType.definition)
      {
        case SoapSimpleTypeDefinition.restriction:
        {
          result ~= aliasTypeFormat.format(simpleType.name, simpleType.typeName);
          break;
        }

        case SoapSimpleTypeDefinition.list:
        {
          auto listTypeResult = classTypeElementFormat.format(simpleType.typeName, "_value_");
          listTypeResult ~= classTypeElementFormat.format("alias", "_value_ this");

          result ~= classTypeFormat.format(simpleType.name, listTypeResult);
          break;
        }
      }
      continue;
    }
  }

  return result ? result : "";
}
